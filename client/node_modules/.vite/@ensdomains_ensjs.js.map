{
  "version": 3,
  "sources": ["../@ensdomains/ensjs/dist/esm/contracts/getContractAddress.mjs", "../@ensdomains/ensjs/dist/esm/contracts/index.mjs", "../@adraffy/ens-normalize/dist/index.js", "../@ethersproject/solidity/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts", "../@ethersproject/solidity/node_modules/@ethersproject/sha2/src.ts/types.ts", "../@ethersproject/solidity/node_modules/@ethersproject/logger/src.ts/_version.ts", "../@ethersproject/solidity/node_modules/@ethersproject/logger/src.ts/index.ts", "../@ethersproject/solidity/node_modules/@ethersproject/sha2/src.ts/_version.ts", "../@ethersproject/solidity/src.ts/_version.ts", "../@ethersproject/solidity/src.ts/index.ts", "../@ensdomains/ensjs/dist/esm/utils/labels.mjs", "../@ensdomains/ensjs/dist/esm/utils/normalise.mjs", "../@ensdomains/ensjs/dist/esm/GqlManager.mjs", "../@ensdomains/ensjs/dist/esm/utils/singleCall.mjs", "../@ensdomains/ensjs/dist/esm/utils/writeTx.mjs", "../@ensdomains/ensjs/dist/esm/index.mjs"],
  "sourcesContent": ["// src/contracts/getContractAddress.ts\nvar addresses = {\n  BaseRegistrarImplementation: {\n    \"1\": \"0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85\",\n    \"3\": \"0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85\",\n    \"4\": \"0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85\",\n    \"5\": \"0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85\"\n  },\n  DNSRegistrar: {\n    \"1\": \"0x58774Bb8acD458A640aF0B88238369A167546ef2\",\n    \"3\": \"0xdB328BA5FEcb432AF325Ca59E3778441eF5aa14F\",\n    \"5\": \"0x8edc487D26F6c8Fa76e032066A3D4F87E273515d\"\n  },\n  ETHRegistrarController: {\n    \"1\": \"0x283af0b28c62c092c9727f1ee09c02ca627eb7f5\",\n    \"3\": \"0xa5627AB7Ae47063B533622C34FEBDb52d3281dF8\",\n    \"4\": \"0x283af0b28c62c092c9727f1ee09c02ca627eb7f5\",\n    \"5\": \"0xCc5e7dB10E65EED1BBD105359e7268aa660f6734\"\n  },\n  Multicall: \"0xcA11bde05977b3631167028862bE2a173976CA11\",\n  NameWrapper: {\n    \"1\": \"0x0000000000000000000000000000000000000000\",\n    \"3\": \"0xF82155e2a43Be0871821E9654Fc8Ae894FB8307C\",\n    \"4\": \"0x0000000000000000000000000000000000000000\",\n    \"5\": \"0x114D4603199df73e7D157787f8778E21fCd13066\"\n  },\n  PublicResolver: {\n    \"1\": \"0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41\",\n    \"3\": \"0x13F0659Ee6bb7484C884FEeFb7F75C93951ef837\",\n    \"5\": \"0xd7a4F6473f32aC2Af804B3686AE8F1932bC35750\"\n  },\n  ENSRegistry: {\n    \"1\": \"0x00000000000c2e074ec69a0dfb2997ba6c7d2e1e\",\n    \"3\": \"0x00000000000c2e074ec69a0dfb2997ba6c7d2e1e\",\n    \"4\": \"0x00000000000c2e074ec69a0dfb2997ba6c7d2e1e\",\n    \"5\": \"0x00000000000c2e074ec69a0dfb2997ba6c7d2e1e\"\n  },\n  ReverseRegistrar: {\n    \"1\": \"0x084b1c3C81545d370f3634392De611CaaBFf8148\",\n    \"3\": \"0x806246b52f8cB61655d3038c58D2f63Aa55d4edE\",\n    \"5\": \"0x4f7A657451358a22dc397d5eE7981FfC526cd856\"\n  },\n  UniversalResolver: {\n    \"1\": \"0xc0497e381f536be9ce14b0dd3817cbcae57d2f62\",\n    \"5\": \"0x56522d00c410a43bffdf00a9a569489297385790\"\n  },\n  BulkRenewal: {\n    \"1\": \"0xfF252725f6122A92551A5FA9a6b6bf10eb0Be035\",\n    \"3\": \"0x051b02245D826757EfaF5C6209D4D79FB39FBC45\",\n    \"5\": \"0xa9e1df95a79C768aA435805b28E1B54Bb5ead063\"\n  }\n};\nvar getContractAddress = (networkId) => (contractName) => {\n  try {\n    return typeof addresses[contractName] === \"string\" ? addresses[contractName] : addresses[contractName][networkId];\n  } catch {\n    throw new Error(\n      `No address for contract ${contractName} on network ${networkId}`\n    );\n  }\n};\nexport {\n  getContractAddress\n};\n", "// src/contracts/index.ts\nvar ContractManager = class {\n  provider;\n  fetchAddress;\n  getModule = async (name) => {\n    const mod = await import(\n      /* webpackMode: \"lazy\", webpackChunkName: \"[request]\", webpackPreload: true, webpackExclude: /.*\\.ts$/ */\n      `../generated/factories/${name}__factory`\n    );\n    return mod[`${name}__factory`];\n  };\n  constructor(provider, fetchAddress, getModule) {\n    this.provider = provider;\n    this.fetchAddress = fetchAddress;\n    if (getModule) {\n      this.getModule = getModule;\n    }\n  }\n  generateContractGetter = (name) => {\n    return async (passedProvider, address) => {\n      const mod = await this.getModule(name);\n      const inputAddress = address || this.fetchAddress(name);\n      const provider = passedProvider || this.provider;\n      return mod.connect(inputAddress, provider);\n    };\n  };\n  getPublicResolver = this.generateContractGetter(\"PublicResolver\");\n  getUniversalResolver = this.generateContractGetter(\"UniversalResolver\");\n  getRegistry = this.generateContractGetter(\"ENSRegistry\");\n  getReverseRegistrar = this.generateContractGetter(\"ReverseRegistrar\");\n  getNameWrapper = this.generateContractGetter(\"NameWrapper\");\n  getDNSRegistrar = this.generateContractGetter(\"DNSRegistrar\");\n  getBaseRegistrar = this.generateContractGetter(\n    \"BaseRegistrarImplementation\"\n  );\n  getEthRegistrarController = this.generateContractGetter(\n    \"ETHRegistrarController\"\n  );\n  getMulticall = this.generateContractGetter(\"Multicall\");\n  getBulkRenewal = this.generateContractGetter(\"BulkRenewal\");\n};\nexport {\n  ContractManager as default\n};\n", "function decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r$1 = read_compressed_payload('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');\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r = read_compressed_payload('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');\n\n// https://unicode.org/reports/tr15/\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nconst SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\nconst EXCLUSIONS = new Set(read_sorted(r));\r\nconst DECOMP = new Map();\r\nconst RECOMP = new Map();\r\nfor (let [cp, cps] of read_mapped(r)) {\r\n\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\tlet [a, b] = cps;\r\n\t\tlet bucket = RECOMP.get(a);\r\n\t\tif (!bucket) {\r\n\t\t\tbucket = new Map();\r\n\t\t\tRECOMP.set(a, bucket);\r\n\t\t}\r\n\t\tbucket.set(b, cp);\r\n\t}\r\n\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n}\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\n//const t0 = performance.now();\r\n\r\nconst STOP = 0x2E;\r\nconst FE0F = 0xFE0F;\r\nconst STOP_CH = '.';\r\nconst UNIQUE_PH = 1;\r\nconst HYPHEN = 0x2D;\r\n\r\nfunction read_set() {\r\n\treturn new Set(read_sorted(r$1));\r\n}\r\nconst MAPPED = new Map(read_mapped(r$1)); \r\nconst IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\r\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\r\n// 20230217: we still need all CM for proper error formatting\r\n// but norm only needs NSM subset that are potentially-valid\r\nconst CM = read_set();\r\nconst NSM = new Set(read_sorted(r$1).map(function(i) { return this[i]; }, [...CM]));\r\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/\r\nconst ESCAPE = read_set(); // characters that should not be printed\r\nconst NFC_CHECK = read_set();\r\nconst CHUNKS = read_sorted_arrays(r$1);\r\nfunction read_chunked() {\r\n\t// deduplicated sets + uniques\r\n\treturn new Set([read_sorted(r$1).map(i => CHUNKS[i]), read_sorted(r$1)].flat(2));\r\n}\r\nconst UNRESTRICTED = r$1();\r\nconst GROUPS = read_array_while(i => {\r\n\t// minifier property mangling seems unsafe\r\n\t// so these are manually renamed to single chars\r\n\tlet N = read_array_while(r$1).map(x => x+0x60);\r\n\tif (N.length) {\r\n\t\tlet R = i >= UNRESTRICTED; // first arent restricted\r\n\t\tN[0] -= 32; // capitalize\r\n\t\tN = str_from_cps(N);\r\n\t\tif (R) N=`Restricted[${N}]`;\r\n\t\tlet P = read_chunked(); // primary\r\n\t\tlet Q = read_chunked(); // secondary\r\n\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t//let M = r()-1; // combining mark\r\n\t\tlet M = !r$1(); // not-whitelisted, check for NSM\r\n\t\t// code currently isn't needed\r\n\t\t/*if (M < 0) { // whitelisted\r\n\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\tlet i = r();\r\n\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t})];\r\n\t\t\t}));\r\n\t\t}*/\r\n\t\treturn {N, P, M, R, V: new Set(V)};\r\n\t}\r\n});\r\nconst WHOLE_VALID = read_set();\r\nconst WHOLE_MAP = new Map();\r\n// decode compressed wholes\r\n[...WHOLE_VALID, ...read_set()].sort((a, b) => a-b).map((cp, i, v) => {\r\n\tlet d = r$1(); \r\n\tlet w = v[i] = d ? v[i-d] : {V: [], M: new Map()};\r\n\tw.V.push(cp); // add to member set\r\n\tif (!WHOLE_VALID.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t}\r\n});\r\n// compute confusable-extent complements\r\nfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t// connect all groups that have each whole character\r\n\tlet recs = [];\r\n\tfor (let cp of V) {\r\n\t\tlet gs = GROUPS.filter(g => g.V.has(cp));\r\n\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\tif (!rec) {\r\n\t\t\trec = {G: new Set(), V: []};\r\n\t\t\trecs.push(rec);\r\n\t\t}\r\n\t\trec.V.push(cp);\r\n\t\tgs.forEach(g => rec.G.add(g));\r\n\t}\r\n\t// per character cache groups which are not a member of the extent\r\n\tlet union = recs.flatMap(({G}) => [...G]);\r\n\tfor (let {G, V} of recs) {\r\n\t\tlet complement = new Set(union.filter(g => !G.has(g)));\r\n\t\tfor (let cp of V) {\r\n\t\t\tM.set(cp, complement);\r\n\t\t}\r\n\t}\r\n}\r\nlet union = new Set(); // exists in 1+ groups\r\nlet multi = new Set(); // exists in 2+ groups\r\nfor (let g of GROUPS) {\r\n\tfor (let cp of g.V) {\r\n\t\t(union.has(cp) ? multi : union).add(cp);\r\n\t}\r\n}\r\n// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\nfor (let cp of union) {\r\n\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t}\r\n}\r\nconst VALID = new Set([...union, ...nfd(union)]); // possibly valid\r\n\r\n// decode emoji\r\nconst EMOJI_SORTED = read_sorted(r$1); // temporary\r\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\r\nconst EMOJI_ROOT = read_emoji_trie([]);\r\nfunction read_emoji_trie(cps) {\r\n\tlet B = read_array_while(() => {\r\n\t\tlet keys = read_sorted(r$1).map(i => EMOJI_SORTED[i]);\r\n\t\tif (keys.length) return read_emoji_trie(keys);\r\n\t}).sort((a, b) => b.Q.size - a.Q.size); // sort by likelihood\r\n\tlet temp = r$1();\r\n\tlet V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\r\n\ttemp = (temp / 3)|0;\r\n\tlet F = temp & 1; // allow FE0F\r\n\ttemp >>= 1;\r\n\tlet S = temp & 1; // save\r\n\tlet C = temp & 2; // check\r\n\treturn {B, V, F, S, C, Q: new Set(cps)};\r\n}\r\n//console.log(performance.now() - t0);\r\n\r\n// free tagging system\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; }\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('\u25CC');\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error('invalid label extension');\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\nfunction is_combining_mark(cp) {\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(process(explode_cp(label), nf).flatMap(x => x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(ens_split(name));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet split = ens_split(name, true);\r\n\t// this is experimental\r\n\tfor (let {type, output, error} of split) {\r\n\t\tif (error) continue;\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"\u2010\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// \u03BE => \u039E if not greek\r\n\t\tif (type !== 'Greek') { \r\n\t\t\tlet prev = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet next = output.indexOf(0x3BE, prev);\r\n\t\t\t\tif (next < 0) break;\r\n\t\t\t\toutput[next] = 0x39E; \r\n\t\t\t\tprev = next + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(split);\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\tlet norm;\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens[0];\r\n\t\t\t\tlet emoji = token_count > 1 || chars.is_emoji;\r\n\t\t\t\tif (!emoji && chars.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t\tnorm = chars;\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\t// only needed for ascii\r\n\t\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\t\tcheck_label_extension(norm);\r\n\t\t\t\t\t// cant have fenced\r\n\t\t\t\t\t// cant have cm\r\n\t\t\t\t\t// cant have wholes\r\n\t\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\t\ttype = 'ASCII';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (emoji) { // there is at least one emoji\r\n\t\t\t\t\t\tinfo.emoji = true; \r\n\t\t\t\t\t\tchars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnorm = tokens.flatMap(x => !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\t\tlet unique = [...new Set(chars)];\r\n\t\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\tinfo.output = norm;\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = []; // TODO: can this be avoided?\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : [...set];\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaning groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => g.V.has(cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => g.V.has(cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (groups === GROUPS) {\r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp));\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tlet {V, M} = g;\r\n\tfor (let cp of cps) {\r\n\t\tif (!V.has(cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc\uD83D\uDCA9d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\nfunction process(input, nf) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(emoji);\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps);\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// allows optional FE0F\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet saved;\r\n\tlet stack = [];\r\n\tlet pos = cps.length;\r\n\tif (eaten) eaten.length = 0; // clear input buffer (if needed)\r\n\twhile (pos) {\r\n\t\tlet cp = cps[--pos];\r\n\t\tnode = node.B.find(x => x.Q.has(cp));\r\n\t\tif (!node) break;\r\n\t\tif (node.S) { // remember\r\n\t\t\tsaved = cp;\r\n\t\t} else if (node.C) { // check exclusion\r\n\t\t\tif (cp === saved) break;\r\n\t\t}\r\n\t\tstack.push(cp);\r\n\t\tif (node.F) {\r\n\t\t\tstack.push(FE0F);\r\n\t\t\tif (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\r\n\t\t}\r\n\t\tif (node.V) { // this is a valid emoji (so far)\r\n\t\t\temoji = conform_emoji_copy(stack, node);\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t// *** this code currently isn't needed ***\r\n\tif (!emoji) {\r\n\t\tlet cp = cps[cps.length-1];\r\n\t\tif (EMOJI_SOLO.has(cp)) {\r\n\t\t\tif (eaten) eaten.push(cp);\r\n\t\t\temoji = Emoji.of(cp);\r\n\t\t\tcps.pop();\r\n\t\t}\r\n\t}\r\n\t*/\r\n\treturn emoji;\r\n}\r\n\r\n// create a copy and fix any unicode quirks\r\nfunction conform_emoji_copy(cps, node) {\r\n\tlet copy = Emoji.from(cps); // copy stack\r\n\tif (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\r\n\treturn copy;\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\t// *** this code currently isn't needed ***\r\n\t//let ret = [...EMOJI_SOLO].map(x => [x]);\r\n\tlet ret = [];\r\n\tbuild(EMOJI_ROOT, []);\r\n\treturn ret.sort(compare_arrays);\r\n\tfunction build(node, cps, saved) {\r\n\t\tif (node.S) { \r\n\t\t\tsaved = cps[cps.length-1];\r\n\t\t} else if (node.C) { \r\n\t\t\tif (saved === cps[cps.length-1]) return;\r\n\t\t}\r\n\t\tif (node.F) cps.push(FE0F);\r\n\t\tif (node.V) ret.push(conform_emoji_copy(cps, node));\r\n\t\tfor (let br of node.B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\tbuild(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\t\t\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({type: TY_EMOJI, emoji, input: eaten.slice(), cps: filter_fe0f(emoji)});\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };\n", null, null, null, null, null, null, null, "// src/utils/labels.ts\nimport { keccak256 as solidityKeccak256 } from \"@ethersproject/solidity\";\nimport { truncateFormat } from \"./format.mjs\";\nvar hasLocalStorage = typeof localStorage !== \"undefined\";\nvar labelhash = (input) => solidityKeccak256([\"string\"], [input]);\nvar keccakFromString = (input) => labelhash(input);\nfunction decodeLabelhash(hash) {\n  if (!(hash.startsWith(\"[\") && hash.endsWith(\"]\"))) {\n    throw Error(\n      \"Expected encoded labelhash to start and end with square brackets\"\n    );\n  }\n  if (hash.length !== 66) {\n    throw Error(\"Expected encoded labelhash to have a length of 66\");\n  }\n  return `0x${hash.slice(1, -1)}`;\n}\nfunction encodeLabelhash(hash) {\n  if (!hash.startsWith(\"0x\")) {\n    throw new Error(\"Expected label hash to start with 0x\");\n  }\n  if (hash.length !== 66) {\n    throw new Error(\"Expected label hash to have a length of 66\");\n  }\n  return `[${hash.slice(2)}]`;\n}\nfunction isEncodedLabelhash(hash) {\n  return hash.startsWith(\"[\") && hash.endsWith(\"]\") && hash.length === 66;\n}\nfunction getLabels() {\n  return hasLocalStorage ? JSON.parse(localStorage.getItem(\"ensjs:labels\")) || {} : {};\n}\nfunction _saveLabel(hash, label) {\n  if (!hasLocalStorage)\n    return hash;\n  const labels = getLabels();\n  localStorage.setItem(\n    \"ensjs:labels\",\n    JSON.stringify({\n      ...labels,\n      [hash]: label\n    })\n  );\n  return hash;\n}\nfunction saveLabel(label) {\n  const hash = `${labelhash(label.toLowerCase())}`;\n  return _saveLabel(hash, label);\n}\nfunction saveName(name) {\n  const nameArray = name.split(\".\");\n  for (const label of nameArray) {\n    if (!isEncodedLabelhash(label)) {\n      saveLabel(label);\n    }\n  }\n}\nfunction checkLabel(hash) {\n  const labels = getLabels();\n  if (isEncodedLabelhash(hash)) {\n    return labels[decodeLabelhash(hash)] || hash;\n  }\n  return hash;\n}\nfunction encodeLabel(label) {\n  try {\n    return encodeLabelhash(label);\n  } catch {\n    return label;\n  }\n}\nfunction parseName(name) {\n  const nameArray = name.split(\".\");\n  return nameArray.map((label) => encodeLabel(label)).join(\".\");\n}\nfunction checkIsDecrypted(string) {\n  return !string?.includes(\"[\");\n}\nfunction decryptName(name) {\n  return name.split(\".\").map((label) => checkLabel(label)).join(\".\");\n}\nvar truncateUndecryptedName = (name) => truncateFormat(name);\nfunction checkLocalStorageSize() {\n  if (!hasLocalStorage)\n    return \"Empty (0 KB)\";\n  let allStrings = \"\";\n  for (const key in window.localStorage) {\n    if (Object.prototype.hasOwnProperty.call(window.localStorage, key)) {\n      allStrings += window.localStorage[key];\n    }\n  }\n  return allStrings ? `${3 + allStrings.length * 16 / (8 * 1024)} KB` : \"Empty (0 KB)\";\n}\nvar encodedLabelRegex = /\\[[a-fA-F0-9]{64}\\]/g;\nvar getEncryptedLabelAmount = (name) => name.match(encodedLabelRegex)?.length || 0;\nexport {\n  checkIsDecrypted,\n  checkLabel,\n  checkLocalStorageSize,\n  decodeLabelhash,\n  decryptName,\n  encodeLabel,\n  encodeLabelhash,\n  getEncryptedLabelAmount,\n  isEncodedLabelhash,\n  keccakFromString,\n  labelhash,\n  parseName,\n  saveLabel,\n  saveName,\n  truncateUndecryptedName\n};\n", "// src/utils/normalise.ts\nimport {\n  ens_beautify,\n  ens_emoji,\n  ens_normalize,\n  ens_normalize_fragment,\n  ens_split,\n  ens_tokenize,\n  is_combining_mark,\n  should_escape\n} from \"@adraffy/ens-normalize\";\nimport { concat, hexlify } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { decodeLabelhash, isEncodedLabelhash } from \"./labels.mjs\";\nvar zeros = new Uint8Array(32);\nzeros.fill(0);\nvar normalise = (name) => name ? ens_normalize(name) : name;\nvar namehash = (name) => {\n  let result = zeros;\n  if (name) {\n    const labels = name.split(\".\");\n    for (let i = labels.length - 1; i >= 0; i -= 1) {\n      let labelSha;\n      if (isEncodedLabelhash(labels[i])) {\n        labelSha = decodeLabelhash(labels[i]);\n      } else {\n        const normalised = normalise(labels[i]);\n        labelSha = keccak256(toUtf8Bytes(normalised));\n      }\n      result = keccak256(concat([result, labelSha]));\n    }\n  } else {\n    result = hexlify(zeros);\n  }\n  return result;\n};\nvar beautify = ens_beautify;\nvar emoji = ens_emoji;\nvar normalizeFragment = ens_normalize_fragment;\nvar split = ens_split;\nvar tokenise = ens_tokenize;\nvar isCombiningMark = is_combining_mark;\nvar shouldEscape = should_escape;\nexport {\n  beautify,\n  emoji,\n  isCombiningMark,\n  namehash,\n  normalise,\n  normalizeFragment,\n  shouldEscape,\n  split,\n  tokenise\n};\n", "// src/GqlManager.ts\nimport { namehash } from \"./utils/normalise.mjs\";\nvar generateSelection = (selection) => ({\n  kind: \"Field\",\n  name: {\n    kind: \"Name\",\n    value: selection\n  },\n  arguments: [],\n  directives: [],\n  alias: void 0,\n  selectionSet: void 0\n});\nvar enter = (node) => {\n  let hasName = false;\n  let hasId = false;\n  for (const selection of node.selections) {\n    if (\"name\" in selection) {\n      if (selection.name.value === \"name\")\n        hasName = true;\n      else if (selection.name.value === \"id\")\n        hasId = true;\n    }\n  }\n  if (hasName && !hasId) {\n    node.selections = [...node.selections, generateSelection(\"id\")];\n    return node;\n  }\n};\nvar requestMiddleware = (visit, parse, print) => (request) => {\n  const requestBody = JSON.parse(request.body);\n  const rawQuery = requestBody.query;\n  const parsedQuery = parse(rawQuery);\n  const updatedQuery = visit(parsedQuery, {\n    SelectionSet: {\n      enter\n    }\n  });\n  return {\n    ...request,\n    body: JSON.stringify({ ...requestBody, query: print(updatedQuery) })\n  };\n};\nvar responseMiddleware = (traverse) => (response) => {\n  traverse(response).forEach(function(responseItem) {\n    if (responseItem instanceof Object && responseItem.name) {\n      if (responseItem.name && responseItem.name.includes(\"[\")) {\n        return;\n      }\n      const hashedName = namehash(responseItem.name);\n      if (responseItem.id !== hashedName) {\n        this.update({ ...responseItem, name: hashedName, invalidName: true });\n      }\n    }\n  });\n  return response;\n};\nvar GqlManager = class {\n  gql = (query) => query.join();\n  client = {\n    request: () => Promise.resolve(null)\n  };\n  setUrl = async (url) => {\n    if (url) {\n      const [imported, traverse, { visit, parse, print }] = await Promise.all([\n        import(\"graphql-request\"),\n        import(\"traverse\"),\n        import(\"graphql/language\")\n      ]);\n      this.client = new imported.GraphQLClient(url, {\n        requestMiddleware: requestMiddleware(visit, parse, print),\n        responseMiddleware: responseMiddleware(traverse.default)\n      });\n      this.gql = imported.gql;\n    } else {\n      this.client = {\n        request: () => Promise.resolve(null)\n      };\n      this.gql = (query) => query.join();\n    }\n  };\n};\nexport {\n  GqlManager as default,\n  enter,\n  requestMiddleware,\n  responseMiddleware\n};\n", "// src/utils/singleCall.ts\nvar singleCall_default = async (provider, ensData, func, ...data) => {\n  const { passthrough, ...rawData } = await func.raw(ensData, ...data);\n  const result = await provider.call({ ...rawData, ccipReadEnabled: true }).catch(() => null);\n  if (!result)\n    return;\n  if (passthrough)\n    return func.decode(ensData, result, passthrough, ...data);\n  return func.decode(ensData, result, ...data);\n};\nexport {\n  singleCall_default as default\n};\n", "// src/utils/writeTx.ts\nvar withCustomData = (tx, customData) => customData ? { ...tx, customData } : tx;\nvar writeTx_default = (signer, populate) => ({ customData, ...tx }) => populate ? withCustomData(tx, customData) : signer.sendTransaction(tx).then((r) => withCustomData(r, customData));\nexport {\n  writeTx_default as default\n};\n", "// src/index.ts\nimport { getContractAddress as _getContractAddress } from \"./contracts/getContractAddress.mjs\";\nimport ContractManager from \"./contracts/index.mjs\";\nimport GqlManager from \"./GqlManager.mjs\";\nimport singleCall from \"./utils/singleCall.mjs\";\nimport writeTx from \"./utils/writeTx.mjs\";\nvar graphURIEndpoints = {\n  1: \"https://api.thegraph.com/subgraphs/name/ensdomains/ens\",\n  3: \"https://api.thegraph.com/subgraphs/name/ensdomains/ensropsten\",\n  4: \"https://api.thegraph.com/subgraphs/name/ensdomains/ensrinkeby\",\n  5: \"https://api.thegraph.com/subgraphs/name/ensdomains/ensgoerli\"\n};\nvar ENS = class {\n  options;\n  provider;\n  graphURI;\n  initialProvider;\n  contracts;\n  getContractAddress = _getContractAddress;\n  gqlInstance = new GqlManager();\n  constructor(options) {\n    this.options = options;\n    this.getContractAddress = options?.getContractAddress || _getContractAddress;\n  }\n  checkInitialProvider = async () => {\n    if (!this.initialProvider) {\n      return;\n    }\n    await this.setProvider(this.initialProvider);\n  };\n  forwardDependenciesFromArray = (dependencies) => Object.fromEntries(\n    dependencies.map((dep) => [dep, this[dep]])\n  );\n  getModule = async (path, exportName) => {\n    let mod = await import(\n      /* webpackMode: \"lazy\", webpackChunkName: \"[request]\", webpackPreload: true, webpackExclude: /.*\\.ts$/ */\n      `./functions/${path}`\n    );\n    if (mod.default?.[exportName]) {\n      mod = mod.default;\n    }\n    return mod;\n  };\n  getFunction = (subFunc, writeable, exportName, mod, _path) => subFunc && !writeable ? mod[exportName][subFunc] : mod[exportName];\n  importGenerator = (path, dependencies, exportName = \"default\", subFunc, passthrough) => {\n    if (subFunc === \"batch\") {\n      return (...args) => ({ args, ...passthrough });\n    }\n    const thisRef = this;\n    const mainFunc = async function(...args) {\n      await thisRef.checkInitialProvider();\n      const mod = await thisRef.getModule(path, exportName);\n      if (subFunc !== \"combine\") {\n        const writeable = subFunc === \"write\" || subFunc === \"populateTransaction\";\n        const func = thisRef.getFunction(\n          subFunc,\n          writeable,\n          exportName,\n          mod,\n          path\n        );\n        let dependenciesToForward2 = thisRef.forwardDependenciesFromArray(dependencies);\n        if (writeable) {\n          const options = args[1] || {};\n          const signer = options.signer || thisRef.provider?.getSigner(options.addressOrIndex);\n          const populate = subFunc === \"populateTransaction\";\n          if (!signer) {\n            throw new Error(\"No signer specified\");\n          }\n          delete options.addressOrIndex;\n          delete options.signer;\n          dependenciesToForward2 = { ...dependenciesToForward2, signer };\n          return func(dependenciesToForward2, args[0], options).then(\n            writeTx(signer, populate)\n          );\n        }\n        return func(dependenciesToForward2, ...args);\n      }\n      const dependenciesToForward = thisRef.forwardDependenciesFromArray(dependencies);\n      return singleCall(\n        thisRef.provider,\n        dependenciesToForward,\n        thisRef.getFunction(void 0, void 0, exportName, mod, path),\n        ...args\n      );\n    };\n    if (subFunc === \"combine\") {\n      mainFunc.raw = this.importGenerator(\n        path,\n        dependencies,\n        exportName,\n        \"raw\"\n      );\n      mainFunc.decode = this.importGenerator(\n        path,\n        dependencies,\n        exportName,\n        \"decode\"\n      );\n      mainFunc.batch = this.importGenerator(\n        path,\n        dependencies,\n        exportName,\n        \"batch\",\n        { raw: mainFunc.raw, decode: mainFunc.decode }\n      );\n    } else if (subFunc === \"write\") {\n      mainFunc.populateTransaction = this.importGenerator(\n        path,\n        dependencies,\n        exportName,\n        \"populateTransaction\"\n      );\n    }\n    return mainFunc;\n  };\n  generateFunction = (path, dependencies, exportName = \"default\") => this.importGenerator(path, dependencies, exportName);\n  generateWriteFunction = (path, dependencies, exportName = \"default\") => this.importGenerator(\n    path,\n    dependencies,\n    exportName,\n    \"write\"\n  );\n  generateRawFunction = (path, dependencies, exportName = \"default\") => this.importGenerator(\n    path,\n    dependencies,\n    exportName,\n    \"combine\"\n  );\n  setProvider = async (provider) => {\n    this.provider = provider;\n    const network = this.staticNetwork ? this.provider._network.chainId : (await this.provider.getNetwork()).chainId;\n    if (this.options && this.options.graphURI) {\n      this.graphURI = this.options.graphURI;\n    } else {\n      this.graphURI = graphURIEndpoints[network];\n    }\n    await this.gqlInstance.setUrl(this.graphURI);\n    this.contracts = new ContractManager(\n      this.provider,\n      this.getContractAddress(String(network))\n    );\n  };\n  withProvider = (provider) => {\n    const newENS = new ENS(this.options);\n    newENS.initialProvider = provider;\n    return newENS;\n  };\n  batch = this.generateRawFunction(\n    \"initialGetters\",\n    [\"multicallWrapper\"],\n    \"batch\"\n  );\n  getProfile = this.generateFunction(\n    \"initialGetters\",\n    [\n      \"contracts\",\n      \"gqlInstance\",\n      \"getName\",\n      \"resolverMulticallWrapper\",\n      \"multicallWrapper\",\n      \"_getAddr\",\n      \"_getContentHash\",\n      \"_getText\"\n    ],\n    \"getProfile\"\n  );\n  getName = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\"],\n    \"getName\"\n  );\n  getResolver = this.generateRawFunction(\n    \"getResolver\",\n    [\"contracts\"]\n  );\n  getWrapperData = this.generateRawFunction(\"getWrapperData\", [\"contracts\"]);\n  getHistory = this.generateFunction(\n    \"getHistory\",\n    [\"gqlInstance\"],\n    \"getHistory\"\n  );\n  getContentHash = this.generateRawFunction(\"initialGetters\", [\"contracts\", \"universalWrapper\"], \"getContentHash\");\n  _getContentHash = this.generateRawFunction(\"initialGetters\", [\"contracts\"], \"_getContentHash\");\n  getAddr = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\", \"universalWrapper\"],\n    \"getAddr\"\n  );\n  _getAddr = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\"],\n    \"_getAddr\"\n  );\n  getText = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\", \"universalWrapper\"],\n    \"getText\"\n  );\n  _getText = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\"],\n    \"_getText\"\n  );\n  getABI = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\", \"universalWrapper\"],\n    \"getABI\"\n  );\n  _getABI = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\"],\n    \"_getABI\"\n  );\n  getOwner = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\", \"multicallWrapper\", \"gqlInstance\"],\n    \"getOwner\"\n  );\n  getExpiry = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\", \"multicallWrapper\"],\n    \"getExpiry\"\n  );\n  getSubnames = this.generateFunction(\n    \"initialGetters\",\n    [\"gqlInstance\"],\n    \"getSubnames\"\n  );\n  getNames = this.generateFunction(\n    \"initialGetters\",\n    [\"gqlInstance\"],\n    \"getNames\"\n  );\n  getPrice = this.generateRawFunction(\n    \"initialGetters\",\n    [\"contracts\", \"multicallWrapper\"],\n    \"getPrice\"\n  );\n  getDNSOwner = this.generateFunction(\n    \"getDNSOwner\",\n    []\n  );\n  supportsTLD = this.generateFunction(\n    \"initialGetters\",\n    [\"getOwner\", \"provider\"],\n    \"supportsTLD\"\n  );\n  getAvailable = this.generateRawFunction(\n    \"getAvailable\",\n    [\"contracts\"]\n  );\n  getDecryptedName = this.generateRawFunction(\"getDecryptedName\", [\"contracts\", \"gqlInstance\"]);\n  universalWrapper = this.generateRawFunction(\"initialGetters\", [\"contracts\"], \"universalWrapper\");\n  resolverMulticallWrapper = this.generateRawFunction(\"initialGetters\", [\"contracts\"], \"resolverMulticallWrapper\");\n  multicallWrapper = this.generateRawFunction(\"initialGetters\", [\"contracts\", \"provider\"], \"multicallWrapper\");\n  setName = this.generateWriteFunction(\n    \"setName\",\n    [\"contracts\"]\n  );\n  setRecords = this.generateWriteFunction(\n    \"setRecords\",\n    [\"contracts\", \"provider\", \"getResolver\"]\n  );\n  setRecord = this.generateWriteFunction(\n    \"setRecord\",\n    [\"contracts\", \"provider\", \"getResolver\"]\n  );\n  setResolver = this.generateWriteFunction(\n    \"setResolver\",\n    [\"contracts\"]\n  );\n  transferName = this.generateWriteFunction(\"transferName\", [\"contracts\"]);\n  transferController = this.generateWriteFunction(\"transferController\", [\"contracts\"]);\n  wrapName = this.generateWriteFunction(\n    \"wrapName\",\n    [\"contracts\"]\n  );\n  unwrapName = this.generateWriteFunction(\n    \"unwrapName\",\n    [\"contracts\"]\n  );\n  setFuses = this.generateWriteFunction(\n    \"setFuses\",\n    [\"contracts\"]\n  );\n  setChildFuses = this.generateWriteFunction(\"setFuses\", [\"contracts\"], \"setChildFuses\");\n  importDNSSECName = this.generateWriteFunction(\"importDNSSECName\", [\"contracts\", \"provider\", \"signer\"]);\n  createSubname = this.generateWriteFunction(\"createSubname\", [\"contracts\", \"getExpiry\"]);\n  deleteSubname = this.generateWriteFunction(\"deleteSubname\", [\"contracts\"]);\n  transferSubname = this.generateWriteFunction(\"transferSubname\", [\"contracts\"]);\n  commitName = this.generateWriteFunction(\n    \"commitName\",\n    [\"contracts\"]\n  );\n  registerName = this.generateWriteFunction(\"registerName\", [\"contracts\"]);\n  renewNames = this.generateWriteFunction(\n    \"renewNames\",\n    [\"contracts\"]\n  );\n  extendWrappedName = this.generateWriteFunction(\"renewNames\", [\"contracts\"], \"extendWrappedName\");\n};\nexport {\n  ENS,\n  graphURIEndpoints\n};\n"],
  "mappings": "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",
  "names": []
}
